package sources

import (
	"encoding/json"
	"testing"
)

type AutoGenerated struct {
	Args struct {
	} `json:"args"`
	Headers struct {
		Accept                  string `json:"Accept"`
		AcceptEncoding          string `json:"Accept-Encoding"`
		AcceptLanguage          string `json:"Accept-Language"`
		CacheControl            string `json:"Cache-Control"`
		Connection              string `json:"Connection"`
		Host                    string `json:"Host"`
		UpgradeInsecureRequests string `json:"Upgrade-Insecure-Requests"`
		UserAgent               string `json:"User-Agent"`
		XBluecoatVia            string `json:"X-Bluecoat-Via"`
	} `json:"headers"`
	Origin string `json:"origin"`
	URL    string `json:"url"`
}

type testlabels struct {
	Units    string `json:"units"`
	Type     string `json:"type"`
	Name     string `json:"name"`
	Expected string `json:"expected"`
}

func TestGetRequest(t *testing.T) {
	testString := "http://httpbin.org/get"
	response := getRequest(testString)
	if response == nil {
		t.Fatal("Get request has not been completed.")
	}
	A := &AutoGenerated{}
	err := json.Unmarshal(response, A)
	if err != nil {
		t.Fatal("Failed to unmarshal the data.")
	}
	expected := "httpbin.org"
	if A.Headers.Host != expected {
		t.Fatalf("Not receiving the correct host name. Expected: %s, Got: %s", expected, A.Headers.Host)
	}
}

func TestUnmarshal(t *testing.T) {
	testUrl := "http://httpbin.org/get"
	testBody := getRequest(testUrl)
	testMap := &AutoGenerated{}
	unmarshal([]byte(testBody), testMap)
	expected := "httpbin.org"
	if testMap.Headers.Host != expected {
		t.Fatalf("Not receiving correct host name. Expected: %s, Got: %s", expected, testMap.Headers.Host)
	}
	expected = "http://httpbin.org/get"
	if testMap.URL != expected {
		t.Fatalf("Not receiving correct URL. Expected: %s, Got: %s", expected, testMap.URL)
	}
}

func TestWeirdMetrics(t *testing.T) {

	name := make(map[string]string)
	name["disk_total_nanosec"] = "disk_total_nanoseconds"
	name["count / sec"] = "count_per_second"
	name["Kbyte"] = "kilobytes"
	name["nanosec"] = "nanoseconds"
	name["millisec"] = "milliseconds"
	name["failcnt"] = "failcount"
	name["byte"] = "bytes"
	name["Mbyte"] = "megabytes"
	name["sec"] = "seconds"
	name["bytes_byte"] = "bytes"
	name["kilobytes"] = "kilobytes"
	name["seconds"] = "seconds"
	name["nanoseconds"] = "nanoseconds"
	name["milliseconds"] = "milliseconds"
	name["megabytes"] = "megabytes"
	name["bytes"] = "bytes"
	name["kal_byte"] = "kal_bytes"
	name["gorgi_nanosec"] = "gorgi_nanoseconds"
	name["asfdasfr_Mbyte"] = "asfdasfr_megabytes"
	name["pcp_network_interface_baudrate_byte / seconds"] = "pcp_network_interface_baudrate_bytes_per_second"
	name["pcp_network_interface_speed_mbyte / seconds"] = "pcp_network_interface_speed_megabytes_per_second"
	name["pcp_pmcd_cputime_per_pdu_in_microseconds / count"] = "pcp_pmcd_cputime_per_pdu_in_microseconds_per_count"
	name["pcp_network_interface_baudrate_byte / sec"] = "pcp_network_interface_baudrate_bytes_per_second"
	name["pcp_network_interface_speed_mbyte / sec"] = "pcp_network_interface_speed_megabytes_per_second"
	name["pcp_pmcd_cputime_per_pdu_in_microsec / count"] = "pcp_pmcd_cputime_per_pdu_in_microseconds_per_count"
	name["something_unexpected / unit"] = "something_unexpected_per_unit"
	name["another_unexpected/unit"] = "another_unexpected_per_unit"

	for key, val := range name {
		converted := fixNaming(key)
		if converted != val {
			t.Fatalf("Failed when name was %s. Expected: %s, Got: %s", key, val, converted)
		}
	}
}

func TestLabelTypes(t *testing.T) {

	arr := []testlabels{
		{"", "", "kiaal", "kiaal"},
		{"", "", "", ""},
		{"kal", "CoUnTeR", "kal", "kal_kal_total"},
		{"tery", "gagage", "kall", "kall_tery"},
		{"/ tery", "gagage", "kall", "kall_tery"},
		{"/ kal", "CoUnTeR", "kal", "kal_kal_total"},
	}

	for _, element := range arr {
		given := typeLabel(element.Units, element.Type, element.Name)
		if given != element.Expected {
			t.Fatalf("Failed when units was %s, Type was %s, and name was %s. Expected: %s, Got: %s", element.Units, element.Type, element.Name, element.Expected, given)
		}
	}
}
